{"version":3,"file":"docs.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/is-plain-object/index.js","webpack:///./node_modules/is-plain-object/node_modules/isobject/index.js","webpack:///./src/acolorpicker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*!\r\n * a-color-picker\r\n * https://github.com/narsenico/a-color-picker\r\n * \r\n * Copyright (c) 2017-2018, Gianfranco Caldi.\r\n * Released under the MIT License.\r\n */\r\n\r\nimport {\r\n    COLOR_NAMES,\r\n    PALETTE_MATERIAL_500,\r\n    PALETTE_MATERIAL_CHROME,\r\n    rgbToHex,\r\n    hslToRgb,\r\n    rgbToHsl,\r\n    rgbToHsv,\r\n    rgbToInt,\r\n    intToRgb,\r\n    cssColorToRgb,\r\n    cssColorToRgba,\r\n    cssRgbToRgb,\r\n    cssRgbaToRgba,\r\n    parseColorToRgb,\r\n    parseColorToRgba,\r\n    cssHslToHsl,\r\n    cssHslaToHsla,\r\n    parseColorToHsl,\r\n    parseColorToHsla,\r\n    parseColor,\r\n    getLuminance,\r\n    limit,\r\n    ensureArray,\r\n    nvl\r\n} from './utils.js';\r\nimport isPlainObject from 'is-plain-object';\r\nimport HTML_BOX from './acolorpicker.html';\r\n\r\nconst VERSION = '1.1.7';\r\n\r\nconst IS_EDGE = typeof window !== 'undefined' && window.navigator.userAgent.indexOf('Edge') > -1,\r\n    IS_IE11 = typeof window !== 'undefined' && window.navigator.userAgent.indexOf('rv:') > -1;\r\n\r\nconst DEFAULT = {\r\n    id: null,\r\n    attachTo: 'body',\r\n    showHSL: true,\r\n    showRGB: true,\r\n    showHEX: true,\r\n    showAlpha: false,\r\n    color: '#ff0000',\r\n    palette: null,\r\n    paletteEditable: false,\r\n    useAlphaInPalette: 'auto' //true|false|auto\r\n};\r\n\r\nconst SL_BAR_SIZE = [232, 150],\r\n    HUE_BAR_SIZE = [150, 11],\r\n    ALPHA_BAR_SIZE = HUE_BAR_SIZE,\r\n    HUE = 'H',\r\n    SATURATION = 'S',\r\n    LUMINANCE = 'L',\r\n    RGB = 'RGB',\r\n    RED = 'R',\r\n    GREEN = 'G',\r\n    BLUE = 'B',\r\n    RGBHEX = 'RGBHEX',\r\n    COLOR = 'COLOR',\r\n    RGBA_USER = 'RGBA_USER',\r\n    HSLA_USER = 'HSLA_USER',\r\n    ALPHA = 'ALPHA';\r\n\r\nfunction parseElement(element, defaultElement, fallToDefault) {\r\n    if (!element) {\r\n        return defaultElement;\r\n    } else if (element instanceof HTMLElement) {\r\n        return element;\r\n    } else if (element instanceof NodeList) {\r\n        return element[0];\r\n    } else if (typeof element == 'string') {\r\n        return document.querySelector(element);\r\n    } else if (element.jquery) {\r\n        return element.get(0); //TODO: da testare parseElement con jQuery\r\n    } else if (fallToDefault) {\r\n        return defaultElement;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction parseElements(selector) {\r\n    if (!selector) {\r\n        return [];\r\n    } else if (Array.isArray(selector)) {\r\n        return selector;\r\n    } else if (selector instanceof HTMLElement) {\r\n        return [selector];\r\n    } else if (selector instanceof NodeList) {\r\n        return [...selector];\r\n    } else if (typeof selector == 'string') {\r\n        return [...document.querySelectorAll(selector)];\r\n    } else if (selector.jquery) {\r\n        return selector.get(); //TODO: da testare parseElements con jQuery\r\n    } else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction canvasHelper(canvas) {\r\n    const ctx = canvas.getContext('2d'),\r\n        width = +canvas.width,\r\n        height = +canvas.height;\r\n    // questo gradiente da bianco (alto) a nero (basso) viene applicato come sfondo al canvas\r\n    const whiteBlackGradient = ctx.createLinearGradient(1, 1, 1, height - 1);\r\n    whiteBlackGradient.addColorStop(0, 'white');\r\n    whiteBlackGradient.addColorStop(1, 'black');\r\n    return {\r\n        setHue(hue) {\r\n            // gradiente con il colore relavito a lo HUE da sinistra a destra partendo da trasparente a opaco\r\n            // la combinazione del gradiente bianco/nero e questo permette di avere un canvas dove \r\n            // sull'asse delle ordinate è espressa la saturazione, e sull'asse delle ascisse c'è la luminosità\r\n            const colorGradient = ctx.createLinearGradient(0, 0, width - 1, 0);\r\n            colorGradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0)`);\r\n            colorGradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 1)`);\r\n            // applico i gradienti\r\n            ctx.fillStyle = whiteBlackGradient;\r\n            ctx.fillRect(0, 0, width, height);\r\n            ctx.fillStyle = colorGradient;\r\n            ctx.globalCompositeOperation = 'multiply';\r\n            ctx.fillRect(0, 0, width, height);\r\n            ctx.globalCompositeOperation = 'source-over';\r\n        },\r\n\r\n        grabColor(x, y) {\r\n            // recupera il colore del pixel in formato RGBA\r\n            return ctx.getImageData(x, y, 1, 1).data;\r\n        },\r\n\r\n        findColor(r, g, b) {\r\n            const [, s, v] = rgbToHsv(r, g, b);\r\n            const x = s * width;\r\n            const y = height - (v * height);\r\n            return [x, y];\r\n        }\r\n    };\r\n}\r\n\r\nfunction parseAttrBoolean(value, ifNull, ifEmpty) {\r\n    if (value === null) {\r\n        return ifNull;\r\n    } else if (/^\\s*$/.test(value)) {\r\n        return ifEmpty;\r\n    } else if (/true|yes|1/i.test(value)) {\r\n        return true;\r\n    } else if (/false|no|0/i.test(value)) {\r\n        return false;\r\n    } else {\r\n        return ifNull;\r\n    }\r\n}\r\n\r\nfunction copyOptionsFromElement(options, element, attrPrefix = 'acp-') {\r\n    // getAttribute() dovrebbe restituire null se l'attr non esiste, ma le vecchie specifiche prevedono il ritorno di una stringa vuota\r\n    //  quindi è meglio verificare l'esistenza dell'attr con hasAttribute()\r\n    if (element.hasAttribute(attrPrefix + 'show-hsl')) {\r\n        options.showHSL = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-hsl'), DEFAULT.showHSL, true);\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'show-rgb')) {\r\n        options.showRGB = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-rgb'), DEFAULT.showRGB, true);\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'show-hex')) {\r\n        options.showHEX = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-hex'), DEFAULT.showHEX, true);\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'show-alpha')) {\r\n        options.showAlpha = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-alpha'), DEFAULT.showAlpha, true);\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'palette-editable')) {\r\n        options.paletteEditable = parseAttrBoolean(element.getAttribute(attrPrefix + 'palette-editable'), DEFAULT.paletteEditable, true);\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'palette')) {\r\n        const palette = element.getAttribute(attrPrefix + 'palette');\r\n        switch (palette) {\r\n            case 'PALETTE_MATERIAL_500':\r\n                options.palette = PALETTE_MATERIAL_500;\r\n                break;\r\n            case 'PALETTE_MATERIAL_CHROME':\r\n            case '':\r\n                options.palette = PALETTE_MATERIAL_CHROME;\r\n                break;\r\n            default:\r\n                options.palette = palette.split(/[;\\|]/);\r\n                break;\r\n        }\r\n    }\r\n    if (element.hasAttribute(attrPrefix + 'color')) {\r\n        options.color = element.getAttribute(attrPrefix + 'color');\r\n    }\r\n}\r\n\r\nclass ColorPicker {\r\n    constructor(container, options) {\r\n        if (!options) {\r\n            //controllo se siamo nel caso di options passato come primo parametro\r\n            if (container && isPlainObject(container)) {\r\n                // se non trovo options e container è un {} lo considero il vero options\r\n                this.options = Object.assign({}, DEFAULT, container);\r\n                container = parseElement(this.options.attachTo);\r\n            } else {\r\n                // altrimenti uso le opzioni di default\r\n                this.options = Object.assign({}, DEFAULT);\r\n                // nel caso non vengano proprio passati parametri, considero attachTo di default\r\n                container = parseElement(nvl(container, this.options.attachTo));\r\n            }\r\n        } else {\r\n            container = parseElement(container);\r\n            this.options = Object.assign({}, DEFAULT, options);\r\n        }\r\n\r\n        /*         if (container) {\r\n                    // se viene passato al costrutto un elemento HTML uso le opzioni di default\r\n                    this.options = Object.assign({}, DEFAULT, { attachTo: options });\r\n                } else {\r\n                    // altrimenti presumo che sia indicato nelle opzioni qual'è il contenitore\r\n                    this.options = Object.assign({}, DEFAULT, options);\r\n                    container = parseElement(this.options.attachTo);\r\n                }\r\n         */\r\n        if (container) {\r\n            // le opzioni possono essere specificate come attributi dell'elemento contenitore\r\n            // quelle presenti sostituiranno le corrispondenti passate con il parametro options\r\n            copyOptionsFromElement(this.options, container);\r\n\r\n            this.H = 0;\r\n            this.S = 0;\r\n            this.L = 0;\r\n            this.R = 0;\r\n            this.G = 0;\r\n            this.B = 0;\r\n            this.A = 1;\r\n            // andrà a contenere la palette di colori effettivamente usata\r\n            // compresi i colori aggiunti o rimossi dall'utente, non sarà modificabile dirretamente dall'utente\r\n            this.palette = { /*<color>: boolean*/ };\r\n\r\n            // creo gli elementi HTML e li aggiungo al container\r\n            this.element = document.createElement('div');\r\n            if (this.options.id) {\r\n                this.element.id = this.options.id;\r\n            }\r\n            this.element.className = 'a-color-picker';\r\n            // // se falsy viene nascosto .a-color-picker-rgb\r\n            // if (!this.options.showRGB) this.element.className += ' hide-rgb';\r\n            // // se falsy viene nascosto .a-color-picker-hsl\r\n            // if (!this.options.showHSL) this.element.className += ' hide-hsl';\r\n            // // se falsy viene nascosto .a-color-picker-single-input (css hex)\r\n            // if (!this.options.showHEX) this.element.className += ' hide-single-input';\r\n            // // se falsy viene nascosto .a-color-picker-a\r\n            // if (!this.options.showAlpha) this.element.className += ' hide-alpha';\r\n            this.element.innerHTML = HTML_BOX;\r\n            container.appendChild(this.element);\r\n            // preparo il canvas con tutto lo spettro del HUE (da 0 a 360)\r\n            // in base al valore selezionato su questo canvas verrà disegnato il canvas per SL\r\n            const hueBar = this.element.querySelector('.a-color-picker-h');\r\n            this.setupHueCanvas(hueBar);\r\n            this.hueBarHelper = canvasHelper(hueBar);\r\n            this.huePointer = this.element.querySelector('.a-color-picker-h+.a-color-picker-dot');\r\n            // preparo il canvas per SL (saturation e luminance)\r\n            const slBar = this.element.querySelector('.a-color-picker-sl');\r\n            this.setupSlCanvas(slBar);\r\n            this.slBarHelper = canvasHelper(slBar);\r\n            this.slPointer = this.element.querySelector('.a-color-picker-sl+.a-color-picker-dot');\r\n            // preparo il box della preview\r\n            this.preview = this.element.querySelector('.a-color-picker-preview');\r\n            this.setupClipboard(this.preview.querySelector('.a-color-picker-clipbaord'));\r\n            // prearo gli input box\r\n            if (this.options.showHSL) {\r\n                this.setupInput(this.inputH = this.element.querySelector('.a-color-picker-hsl>input[nameref=H]'));\r\n                this.setupInput(this.inputS = this.element.querySelector('.a-color-picker-hsl>input[nameref=S]'));\r\n                this.setupInput(this.inputL = this.element.querySelector('.a-color-picker-hsl>input[nameref=L]'));\r\n            } else {\r\n                this.element.querySelector('.a-color-picker-hsl').remove();\r\n            }\r\n            if (this.options.showRGB) {\r\n                this.setupInput(this.inputR = this.element.querySelector('.a-color-picker-rgb>input[nameref=R]'));\r\n                this.setupInput(this.inputG = this.element.querySelector('.a-color-picker-rgb>input[nameref=G]'));\r\n                this.setupInput(this.inputB = this.element.querySelector('.a-color-picker-rgb>input[nameref=B]'));\r\n            } else {\r\n                this.element.querySelector('.a-color-picker-rgb').remove();\r\n            }\r\n            // preparo l'input per il formato hex css\r\n            if (this.options.showHEX) {\r\n                this.setupInput(this.inputRGBHEX = this.element.querySelector('input[nameref=RGBHEX]'));\r\n            } else {\r\n                this.element.querySelector('.a-color-picker-rgbhex').remove();\r\n            }\r\n            // preparo la palette con i colori predefiniti\r\n            //  (palette può contenere sia un Array che una stringa, entrambi con prop length)\r\n            if (this.options.paletteEditable || (this.options.palette && this.options.palette.length > 0)) {\r\n                this.setPalette(this.element.querySelector('.a-color-picker-palette'));\r\n            } else {\r\n                this.element.querySelector('.a-color-picker-palette').remove();\r\n            }\r\n            // preparo in canvas per l'opacità\r\n            if (this.options.showAlpha) {\r\n                this.setupAlphaCanvas(this.element.querySelector('.a-color-picker-a'));\r\n                this.alphaPointer = this.element.querySelector('.a-color-picker-a+.a-color-picker-dot');\r\n            } else {\r\n                this.element.querySelector('.a-color-picker-alpha').remove();\r\n            }\r\n            // imposto il colore iniziale\r\n            this.onValueChanged(COLOR, this.options.color);\r\n        } else {\r\n            throw new Error(`Container not found: ${this.options.attachTo}`);\r\n        }\r\n    }\r\n\r\n    setupHueCanvas(canvas) {\r\n        canvas.width = HUE_BAR_SIZE[0];\r\n        canvas.height = HUE_BAR_SIZE[1];\r\n        // disegno sul canvas applicando un gradiente lineare che copra tutti i possibili valori di HUE\r\n        //  quindi ci vogliono 361 stop (da 0 a 360), mantendo fisse S e L\r\n        const ctx = canvas.getContext('2d'),\r\n            gradient = ctx.createLinearGradient(0, 0, HUE_BAR_SIZE[0], 0),\r\n            step = 1 / 360;\r\n        // aggiungo tutti i 361 step al gradiente\r\n        for (let ii = 0; ii <= 1; ii += step) {\r\n            gradient.addColorStop(ii, `hsl(${360 * ii}, 100%, 50%)`);\r\n        }\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, HUE_BAR_SIZE[0], HUE_BAR_SIZE[1]);\r\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\r\n        // una volta che il puntatore è premuto sul canvas (mousedown) \r\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\r\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\r\n        // una volta sollevato (mouseup) elimino i listener\r\n        const onMouseMove = (e) => {\r\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, HUE_BAR_SIZE[0]),\r\n                hue = Math.round(x * 360 / HUE_BAR_SIZE[0]);\r\n            this.huePointer.style.left = (x - 7) + 'px';\r\n            this.onValueChanged(HUE, hue);\r\n        };\r\n        const onMouseUp = () => {\r\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\r\n            document.removeEventListener('mousemove', onMouseMove);\r\n            document.removeEventListener('mouseup', onMouseUp);\r\n        };\r\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\r\n        canvas.addEventListener('mousedown', (e) => {\r\n            onMouseMove(e);\r\n            document.addEventListener('mousemove', onMouseMove);\r\n            document.addEventListener('mouseup', onMouseUp);\r\n        });\r\n    }\r\n\r\n    setupSlCanvas(canvas) {\r\n        canvas.width = SL_BAR_SIZE[0];\r\n        canvas.height = SL_BAR_SIZE[1];\r\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\r\n        // una volta che il puntatore è premuto sul canvas (mousedown) \r\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\r\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\r\n        // una volta sollevato (mouseup) elimino i listener\r\n        const onMouseMove = (e) => {\r\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, SL_BAR_SIZE[0] - 1),\r\n                y = limit(e.clientY - canvas.getBoundingClientRect().top, 0, SL_BAR_SIZE[1] - 1),\r\n                c = this.slBarHelper.grabColor(x, y);\r\n            // console.log('grab', x, y, c)\r\n            this.slPointer.style.left = (x - 7) + 'px';\r\n            this.slPointer.style.top = (y - 7) + 'px';\r\n            this.onValueChanged(RGB, c);\r\n        };\r\n        const onMouseUp = () => {\r\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\r\n            document.removeEventListener('mousemove', onMouseMove);\r\n            document.removeEventListener('mouseup', onMouseUp);\r\n        };\r\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\r\n        canvas.addEventListener('mousedown', (e) => {\r\n            onMouseMove(e);\r\n            document.addEventListener('mousemove', onMouseMove);\r\n            document.addEventListener('mouseup', onMouseUp);\r\n        });\r\n    }\r\n\r\n    setupAlphaCanvas(canvas) {\r\n        canvas.width = ALPHA_BAR_SIZE[0];\r\n        canvas.height = ALPHA_BAR_SIZE[1];\r\n        // disegno sul canvas con un gradiente che va dalla piena trasparenza al pieno opaco\r\n        const ctx = canvas.getContext('2d'),\r\n            gradient = ctx.createLinearGradient(0, 0, canvas.width - 1, 0);\r\n        gradient.addColorStop(0, `hsla(0, 0%, 50%, 0)`);\r\n        gradient.addColorStop(1, `hsla(0, 0%, 50%, 1)`);\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, ALPHA_BAR_SIZE[0], ALPHA_BAR_SIZE[1]);\r\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\r\n        // una volta che il puntatore è premuto sul canvas (mousedown) \r\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\r\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\r\n        // una volta sollevato (mouseup) elimino i listener\r\n        const onMouseMove = (e) => {\r\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, ALPHA_BAR_SIZE[0]),\r\n                alpha = +(x / ALPHA_BAR_SIZE[0]).toFixed(2);\r\n            this.alphaPointer.style.left = (x - 7) + 'px';\r\n            this.onValueChanged(ALPHA, alpha);\r\n        };\r\n        const onMouseUp = () => {\r\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\r\n            document.removeEventListener('mousemove', onMouseMove);\r\n            document.removeEventListener('mouseup', onMouseUp);\r\n        };\r\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\r\n        canvas.addEventListener('mousedown', (e) => {\r\n            onMouseMove(e);\r\n            document.addEventListener('mousemove', onMouseMove);\r\n            document.addEventListener('mouseup', onMouseUp);\r\n        });\r\n    }\r\n\r\n    setupInput(input) {\r\n        const min = +input.min,\r\n            max = +input.max,\r\n            prop = input.getAttribute(\"nameref\");\r\n        if (input.hasAttribute('select-on-focus')) {\r\n            input.addEventListener('focus', () => {\r\n                //non funziona in IE/Edge\r\n                input.select();\r\n            });\r\n        }\r\n        if (input.type === 'text') {\r\n            input.addEventListener('change', () => {\r\n                this.onValueChanged(prop, input.value);\r\n            });\r\n        } else {\r\n            if (IS_EDGE || IS_IE11) {\r\n                // edge modifica il valore con le frecce MA non scatena l'evento change\r\n                // quindi le intercetto impostando e.returnValue a false in modo\r\n                // che non il valore non venga modificato anche da edge subito dopo il keydown\r\n                input.addEventListener('keydown', (e) => {\r\n                    if (e.key === 'Up') {\r\n                        input.value = limit((+input.value) + 1, min, max);\r\n                        this.onValueChanged(prop, input.value);\r\n                        e.returnValue = false;\r\n                    } else if (e.key === 'Down') {\r\n                        input.value = limit((+input.value) - 1, min, max);\r\n                        this.onValueChanged(prop, input.value);\r\n                        e.returnValue = false;\r\n                    }\r\n                });\r\n            }\r\n            input.addEventListener('change', () => {\r\n                const value = +input.value;\r\n                this.onValueChanged(prop, limit(value, min, max));\r\n            });\r\n        }\r\n    }\r\n\r\n    setupClipboard(input) {\r\n        // l'input ricopre completamente la preview ma è totalmente trasparente\r\n        input.title = 'click to copy';\r\n        input.addEventListener('click', () => {\r\n            // non uso direttamente inputRGBHEX perchè potrebbe contenere un colore non valido\r\n            //  converto in hexcss4 quindi aggiunge anche il valore hex dell'alpha ma solo se significativo (0<=a<1)\r\n            input.value = parseColor([this.R, this.G, this.B, this.A], 'hexcss4');\r\n            input.select();\r\n            document.execCommand('copy');\r\n        });\r\n    }\r\n\r\n    setPalette(row) {\r\n        // indica se considerare il canale alpha nei controlli della palette\r\n        // se 'auto' dipende dall'opzione showAlpha (se true allora alpha è considerata anche nella palette)\r\n        const useAlphaInPalette = this.options.useAlphaInPalette === 'auto' ? this.options.showAlpha : this.options.useAlphaInPalette;\r\n        // palette è una copia di this.options.palette\r\n        let palette;\r\n        switch (this.options.palette) {\r\n            case 'PALETTE_MATERIAL_500':\r\n                palette = PALETTE_MATERIAL_500;\r\n                break;\r\n            case 'PALETTE_MATERIAL_CHROME':\r\n                palette = PALETTE_MATERIAL_CHROME;\r\n                break;\r\n            default:\r\n                palette = ensureArray(this.options.palette);\r\n                break;\r\n        }\r\n        if (this.options.paletteEditable || palette.length > 0) {\r\n            const addColorToPalette = (color, refElement, fire) => {\r\n                // se il colore è già presente, non creo un nuovo <div> ma sposto quello esistente in coda\r\n                const el = row.querySelector('.a-color-picker-palette-color[data-color=\"' + color + '\"]') ||\r\n                    document.createElement('div');\r\n                el.className = 'a-color-picker-palette-color';\r\n                el.style.backgroundColor = color;\r\n                el.setAttribute('data-color', color);\r\n                el.title = color;\r\n                row.insertBefore(el, refElement);\r\n                this.palette[color] = true;\r\n                if (fire) {\r\n                    this.onPaletteColorAdd(color);\r\n                }\r\n            };\r\n            const removeColorToPalette = (element, fire) => {\r\n                // se element è nullo elimino tutti i colori\r\n                if (element) {\r\n                    row.removeChild(element);\r\n                    this.palette[element.getAttribute('data-color')] = false;\r\n                    if (fire) {\r\n                        this.onPaletteColorRemove(element.getAttribute('data-color'));\r\n                    }\r\n                } else {\r\n                    row.querySelectorAll('.a-color-picker-palette-color[data-color]').forEach(el => {\r\n                        row.removeChild(el);\r\n                    });\r\n                    Object.keys(this.palette).forEach(k => {\r\n                        this.palette[k] = false;\r\n                    });\r\n                    if (fire) {\r\n                        this.onPaletteColorRemove();\r\n                    }\r\n                }\r\n            };\r\n            // solo i colori validi vengono aggiunti alla palette\r\n            palette.map(c => parseColor(c, useAlphaInPalette ? 'rgbcss4' : 'hex'))\r\n                .filter(c => !!c)\r\n                .forEach(c => addColorToPalette(c));\r\n            // in caso di palette editabile viene aggiunto un pulsante + che serve ad aggiungere il colore corrente\r\n            if (this.options.paletteEditable) {\r\n                const el = document.createElement('div');\r\n                el.className = 'a-color-picker-palette-color a-color-picker-palette-add';\r\n                el.innerHTML = '+';\r\n                row.appendChild(el);\r\n                // gestisco eventi di aggiunta/rimozione/selezione colori\r\n                row.addEventListener('click', (e) => {\r\n                    if (/a-color-picker-palette-add/.test(e.target.className)) {\r\n                        if (e.shiftKey) {\r\n                            // rimuove tutti i colori\r\n                            removeColorToPalette(null, true);\r\n                        } else {\r\n                            // aggiungo il colore e triggero l'evento 'oncoloradd'\r\n                            if (useAlphaInPalette) {\r\n                                addColorToPalette(parseColor([this.R, this.G, this.B, this.A], 'rgbcss4'), e.target, true);\r\n                            } else {\r\n                                addColorToPalette(rgbToHex(this.R, this.G, this.B), e.target, true);\r\n                            }\r\n                        }\r\n                    } else if (/a-color-picker-palette-color/.test(e.target.className)) {\r\n                        if (e.shiftKey) {\r\n                            // rimuovo il colore e triggero l'evento 'oncolorremove'\r\n                            removeColorToPalette(e.target, true);\r\n                        } else {\r\n                            // visto che il colore letto da backgroundColor risulta nel formato rgb()\r\n                            // devo usare il valore hex originale\r\n                            this.onValueChanged(COLOR, e.target.getAttribute('data-color'));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                // gestisco il solo evento di selezione del colore\r\n                row.addEventListener('click', (e) => {\r\n                    if (/a-color-picker-palette-color/.test(e.target.className)) {\r\n                        // visto che il colore letto da backgroundColor risulta nel formato rgb()\r\n                        // devo usare il valore hex originale\r\n                        this.onValueChanged(COLOR, e.target.getAttribute('data-color'));\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // la palette con i colori predefiniti viene nasconsta se non ci sono colori\r\n            row.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    onValueChanged(prop, value) {\r\n        // console.log(prop, value);\r\n        switch (prop) {\r\n            case HUE:\r\n                this.H = value;\r\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\r\n                this.slBarHelper.setHue(value);\r\n                this.updatePointerH(this.H);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case SATURATION:\r\n                this.S = value;\r\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case LUMINANCE:\r\n                this.L = value;\r\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case RED:\r\n                this.R = value;\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case GREEN:\r\n                this.G = value;\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case BLUE:\r\n                this.B = value;\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case RGB:\r\n                [this.R, this.G, this.B] = value;\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                break;\r\n            case RGBA_USER:\r\n                [this.R, this.G, this.B, this.A] = value;\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                this.updatePointerA(this.A);\r\n                break;\r\n            case HSLA_USER:\r\n                [this.H, this.S, this.L, this.A] = value;\r\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                this.updatePointerA(this.A);\r\n                break;\r\n            case RGBHEX:\r\n                [this.R, this.G, this.B] = cssColorToRgb(value) || [this.R, this.G, this.B];\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                break;\r\n            case COLOR:\r\n                [this.R, this.G, this.B, this.A] = parseColor(value, 'rgba') || [0, 0, 0, 1];\r\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\r\n                this.slBarHelper.setHue(this.H);\r\n                this.updatePointerH(this.H);\r\n                this.updatePointerSL(this.H, this.S, this.L);\r\n                this.updateInputHSL(this.H, this.S, this.L);\r\n                this.updateInputRGB(this.R, this.G, this.B);\r\n                this.updateInputRGBHEX(this.R, this.G, this.B);\r\n                this.updatePointerA(this.A);\r\n                break;\r\n            case ALPHA:\r\n                this.A = value;\r\n                break;\r\n        }\r\n        this.onColorChanged(this.R, this.G, this.B, this.A);\r\n    }\r\n\r\n    onColorChanged(r, g, b, a) {\r\n        if (a === 1) {\r\n            this.preview.style.backgroundColor = `rgb(${r},${g},${b})`;\r\n        } else {\r\n            this.preview.style.backgroundColor = `rgba(${r},${g},${b},${a})`;\r\n        }\r\n        // this.onchange && this.onchange();\r\n        this.onchange && this.onchange(this.preview.style.backgroundColor);\r\n    }\r\n\r\n    onPaletteColorAdd(color) {\r\n        this.oncoloradd && this.oncoloradd(color);\r\n    }\r\n\r\n    onPaletteColorRemove(color) {\r\n        this.oncolorremove && this.oncolorremove(color);\r\n    }\r\n\r\n    updateInputHSL(h, s, l) {\r\n        if (!this.options.showHSL) return;\r\n\r\n        this.inputH.value = h;\r\n        this.inputS.value = s;\r\n        this.inputL.value = l;\r\n    }\r\n\r\n    updateInputRGB(r, g, b) {\r\n        if (!this.options.showRGB) return;\r\n\r\n        this.inputR.value = r;\r\n        this.inputG.value = g;\r\n        this.inputB.value = b;\r\n    }\r\n\r\n    updateInputRGBHEX(r, g, b) {\r\n        if (!this.options.showHEX) return;\r\n\r\n        this.inputRGBHEX.value = rgbToHex(r, g, b);\r\n    }\r\n\r\n    updatePointerH(h) {\r\n        const x = HUE_BAR_SIZE[0] * h / 360;\r\n        this.huePointer.style.left = (x - 7) + 'px';\r\n    }\r\n\r\n    updatePointerSL(h, s, l) {\r\n        const [r, g, b] = hslToRgb(h, s, l);\r\n        const [x, y] = this.slBarHelper.findColor(r, g, b);\r\n        if (x >= 0) {\r\n            this.slPointer.style.left = (x - 7) + 'px';\r\n            this.slPointer.style.top = (y - 7) + 'px';\r\n        }\r\n    }\r\n\r\n    updatePointerA(a) {\r\n        if (!this.options.showAlpha) return;\r\n\r\n        const x = ALPHA_BAR_SIZE[0] * a;\r\n        this.alphaPointer.style.left = (x - 7) + 'px';\r\n    }\r\n}\r\n\r\nclass EventEmitter {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.listeners = [];\r\n    }\r\n    on(callback) {\r\n        if (callback) {\r\n            this.listeners.push(callback);\r\n        }\r\n    }\r\n    off(callback) {\r\n        if (callback) {\r\n            this.listeners = this.listeners.filter(cb => cb !== callback);\r\n        } else {\r\n            this.listeners = [];\r\n        }\r\n    }\r\n    emit(args, _this) {\r\n        const listeners = this.listeners.slice(0);\r\n        for (let ii = 0; ii < listeners.length; ii++) {\r\n            listeners[ii].apply(_this, args);\r\n        }\r\n    }\r\n}\r\n\r\n// function wrapEventCallback(ctrl, picker, eventName, cb) {\r\n//     if (cb && typeof cb === 'function') {\r\n//         picker['on' + eventName] = () => {\r\n//             cb.call(null, ctrl, ...arguments);\r\n//         };\r\n//     } else {\r\n//         picker['on' + eventName] = null;\r\n//     }\r\n// }\r\n\r\n/**\r\n * Crea il color picker.\r\n * Le opzioni sono:\r\n * - attachTo: elemento DOM al quale aggiungere il picker (default 'body')\r\n * - showHSL: indica se mostrare i campi per la definizione del colore in formato HSL (default true)\r\n * - showRGB: indica se mostrare i campi per la definizione del colore in formato RGB (default true)\r\n * - showHEX: indica se mostrare i campi per la definizione del colore in formato RGB HEX (default true)\r\n * - color: colore iniziale (default '#ff0000')\r\n *\r\n * @param      {Object}          element (opzionale) Un elemento HTML che andrà a contenere il picker\r\n * @param      {Object}          options  (opzionale) Le opzioni di creazione\r\n * @return     {Object}          ritorna un controller per impostare e recuperare il colore corrente del picker\r\n */\r\nfunction createPicker(element, options) {\r\n    let picker = new ColorPicker(element, options);\r\n    // gestione degli eventi: il \"controller\" assegna le callbak degli eventi ai rispettivi EventEmitter\r\n    // quando il picker triggera un evento, \r\n    //  il \"controller\" emette lo stesso evento tramite il rispettivo EventEmitter\r\n    let cbEvents = {\r\n        change: new EventEmitter('change'),\r\n        coloradd: new EventEmitter('coloradd'),\r\n        colorremove: new EventEmitter('colorremove')\r\n    };\r\n    let isChanged = true,\r\n        // memoize per la proprietà all\r\n        memAll = {};\r\n    // non permetto l'accesso diretto al picker\r\n    // ma ritorno un \"controller\" per eseguire solo alcune azioni (get/set colore, eventi, etc.)\r\n    const controller = {\r\n        get element() {\r\n            return picker.element;\r\n        },\r\n\r\n        get rgb() {\r\n            return [picker.R, picker.G, picker.B];\r\n        },\r\n\r\n        set rgb([r, g, b]) {\r\n            [r, g, b] = [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];\r\n            picker.onValueChanged(RGBA_USER, [r, g, b, 1]);\r\n        },\r\n\r\n        get hsl() {\r\n            return [picker.H, picker.S, picker.L];\r\n        },\r\n\r\n        set hsl([h, s, l]) {\r\n            [h, s, l] = [limit(h, 0, 360), limit(s, 0, 100), limit(l, 0, 100)];\r\n            picker.onValueChanged(HSLA_USER, [h, s, l, 1]);\r\n        },\r\n\r\n        get rgbhex() {\r\n            // return rgbToHex(picker.R, picker.G, picker.B);\r\n            return this.all.hex;\r\n        },\r\n\r\n        get rgba() {\r\n            return [picker.R, picker.G, picker.B, picker.A];\r\n        },\r\n\r\n        set rgba([r, g, b, a]) {\r\n            [r, g, b, a] = [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), limit(a, 0, 1)];\r\n            picker.onValueChanged(RGBA_USER, [r, g, b, a]);\r\n        },\r\n\r\n        get hsla() {\r\n            return [picker.H, picker.S, picker.L, picker.A];\r\n        },\r\n\r\n        set hsla([h, s, l, a]) {\r\n            [h, s, l, a] = [limit(h, 0, 360), limit(s, 0, 100), limit(l, 0, 100), limit(a, 0, 1)];\r\n            picker.onValueChanged(HSLA_USER, [h, s, l, a]);\r\n        },\r\n\r\n        /**\r\n         * Ritorna il colore corrente nel formato RGB HEX, \r\n         * oppure nella notazione rgba() con alpha != 1.\r\n         *\r\n         * @return     {string}  colore corrente\r\n         */\r\n        get color() {\r\n            // if (picker.A === 1) {\r\n            //     return this.rgbhex;\r\n            // } else {\r\n            //     return `rgba(${picker.R},${picker.G},${picker.B},${picker.A})`;\r\n            // }\r\n            return this.all.toString();\r\n        },\r\n\r\n        /**\r\n         * Imposta il colore corrente.\r\n         * Accetta:\r\n         * - il nome di un colore (https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)\r\n         * - un colore espresso nel formato RGB HEX sia esteso (#ffdd00) che compatto (#fd0)\r\n         * - un array di interi [R,G,B]\r\n         *\r\n         * @param      {string|array}  color   il colore\r\n         */\r\n        set color(color) {\r\n            picker.onValueChanged(COLOR, color);\r\n        },\r\n\r\n        /**\r\n         * @return  {Object}    oggetto contenente il colore corrente in tutti i formati noti a parseColor()\r\n         */\r\n        get all() {\r\n            if (isChanged) {\r\n                const rgba = [picker.R, picker.G, picker.B, picker.A];\r\n                // la conversione in stringa segue le regole della proprietà color\r\n                const ts = picker.A < 1 ? `rgba(${picker.R},${picker.G},${picker.B},${picker.A})` : rgbToHex(...rgba);\r\n                // passando un oggetto a parseColor come secondo parametro, lo riempirà con tutti i formati disponibili\r\n                memAll = parseColor(rgba, memAll);\r\n                memAll.toString = () => ts;\r\n                isChanged = false;\r\n            }\r\n            // devo per forza passare una copia, altrimenti memAll può esssere modificato dall'esterno\r\n            return Object.assign({}, memAll);\r\n        },\r\n\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get onchange() {\r\n            return cbEvents.change && cbEvents.change.listeners[0];\r\n        },\r\n\r\n        /**\r\n         * @deprecated  usare on('change', cb)\r\n         */\r\n        set onchange(cb) {\r\n            // wrapEventCallback(this, picker, 'change', cb);\r\n            // cbEvents['change'] = cb;\r\n            this.off('change').on('change', cb);\r\n        },\r\n\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get oncoloradd() {\r\n            return cbEvents.coloradd && cbEvents.coloradd.listeners[0];\r\n        },\r\n\r\n        /**\r\n         * @deprecated  usare on('coloradd', cb)\r\n         */\r\n        set oncoloradd(cb) {\r\n            // wrapEventCallback(this, picker, 'coloradd', cb);\r\n            // cbEvents['coloradd'] = cb;\r\n            this.off('coloradd').on('coloradd', cb);\r\n        },\r\n\r\n        /**\r\n         * @deprecated\r\n         */\r\n        get oncolorremove() {\r\n            return cbEvents.colorremove && cbEvents.colorremove.listeners[0];\r\n        },\r\n\r\n        /**\r\n         * @deprecated  usare on('colorremove', cb)\r\n         */\r\n        set oncolorremove(cb) {\r\n            // wrapEventCallback(this, picker, 'colorremove', cb);\r\n            // cbEvents['colorremove'] = cb;\r\n            this.off('colorremove').on('colorremove', cb);\r\n        },\r\n\r\n        /**\r\n         * Ritorna la palette dei colori.\r\n         *\r\n         * @return     {Array}  array di colori in formato hex\r\n         */\r\n        get palette() {\r\n            return Object.keys(picker.palette).filter(k => picker.palette[k]);\r\n        },\r\n\r\n        on(eventName, cb) {\r\n            if (eventName) {\r\n                cbEvents[eventName] && cbEvents[eventName].on(cb);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        off(eventName, cb) {\r\n            if (eventName) {\r\n                cbEvents[eventName] && cbEvents[eventName].off(cb);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        destroy() {\r\n            cbEvents.change.off()\r\n            cbEvents.coloradd.off()\r\n            cbEvents.colorremove.off()\r\n            picker.element.remove()\r\n            cbEvents = null\r\n            picker = null\r\n        }\r\n    };\r\n    // ogni volta che viene triggerato un evento, uso il corrispettivo EventEmitter per propagarlo a tutte le callback associate\r\n    //  le callback vengono richiamate con il \"controller\" come \"this\" \r\n    //  e il primo parametro è sempre il \"controller\" seguito da tutti i parametri dell'evento\r\n    picker.onchange = (...args) => {\r\n        isChanged = true; // così le proprietà in lettura dovranno ricalcolare il loro valore\r\n        cbEvents.change.emit([controller, ...args], controller);\r\n    };\r\n    picker.oncoloradd = (...args) => {\r\n        cbEvents.coloradd.emit([controller, ...args], controller);\r\n    };\r\n    picker.oncolorremove = (...args) => {\r\n        cbEvents.colorremove.emit([controller, ...args], controller);\r\n    };\r\n    // TOOD: trovare un altro nome a ctrl, troppo comune\r\n    // TODO: definirla come readonly\r\n    picker.element.ctrl = controller;\r\n    return controller;\r\n}\r\n\r\n/**\r\n * \r\n * @param {any} selector \r\n * @param {object} options \r\n * @return  un Array di controller così come restituito da createPicker()\r\n */\r\nfunction from(selector, options) {\r\n    // TODO: gestire eventuali errori nella creazione del picker\r\n    const pickers = parseElements(selector).map((el, index) => {\r\n        const picker = createPicker(el, options);\r\n        picker.index = index;\r\n        return picker;\r\n    });\r\n    pickers.on = function (eventName, cb) {\r\n        pickers.forEach(picker => picker.on(eventName, cb));\r\n        return this;\r\n    };\r\n    pickers.off = function (eventName) {\r\n        pickers.forEach(picker => picker.off(eventName));\r\n        return this;\r\n    };\r\n    return pickers;\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n    // solo in ambiente browser inserisco direttamente nella pagina html il css\r\n    //  per sicurezza controllo che non sia già presente\r\n    if (!document.querySelector('head>style[data-source=\"a-color-picker\"]')) {\r\n        const css = require('./acolorpicker.css').toString();\r\n        const style = document.createElement('style');\r\n        style.setAttribute('type', 'text/css');\r\n        style.setAttribute('data-source', 'a-color-picker');\r\n        style.innerHTML = css;\r\n        // TODO: verificare che esista <head>\r\n        document.querySelector('head').appendChild(style);\r\n    }\r\n}\r\n\r\nexport {\r\n    createPicker,\r\n    from,\r\n    parseColorToRgb,\r\n    parseColorToRgba,\r\n    parseColorToHsl,\r\n    parseColorToHsla,\r\n    parseColor,\r\n    rgbToHex,\r\n    hslToRgb,\r\n    rgbToHsl,\r\n    rgbToHsv,\r\n    rgbToInt,\r\n    intToRgb,\r\n    getLuminance,\r\n    COLOR_NAMES,\r\n    PALETTE_MATERIAL_500,\r\n    PALETTE_MATERIAL_CHROME,\r\n    VERSION\r\n};"],"mappings":"AACA;;;;;;ACQA;;;;;;ACAA;;;;;;;AC4BA","sourceRoot":""}